#!/usr/bin/python3
# encoding=utf8
# File name: keysymgen.py
# This file is part of: pyengine
#
# LICENSE
#
# The contents of this file are subject to the Mozilla Public License
# Version 1.1 (the "License"); you may not use this file except in
# compliance with the License. You may obtain a copy of the License at
# http://www.mozilla.org/MPL/
#
# Software distributed under the License is distributed on an "AS IS"
# basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
# the License for the specific language governing rights and limitations
# under the License.
#
# Alternatively, the contents of this file may be used under the terms
# of the GNU General Public license (the  "GPL License"), in which case
# the provisions of GPL License are applicable instead of those above.
#
# FEEDBACK & QUESTIONS
#
# For feedback and questions about pyengine please e-mail one of the
# authors named in the AUTHORS file.
########################################################################
"""
Parse X11/keysymdef.h (given as first argument), generate
our own keysym list from it as a python source file
"""

import re

def parse_keysymdefs(f):
    # this regex was adapted from keysymdef.h
    # all other lines are ignored (perhaps add #ifdef processing
    # for language groups)
    defre = re.compile(r'^#define XK_(?P<name>[a-zA-Z_0-9]+)\s+(?P<hex>0x[0-9a-f]+)\s*(?P<comment>\/\*\s*(.*)\s*\*\/)?\s*$')

    names = []

    # read keysym names and numerical values
    for line in f:
        match = defre.match(line)
        if match:
            names.append((match.group('name'), match.group('hex')))

    return names

def mangle_cxx_name(name):
    if name[0] in "0123456789":
        return "_" + name
    elif name in {"union"}:
        return name + "_"
    else:
        return name

def write_cxx_header(fo, args, names):
    fo.write('''
// DO NOT EDIT -- autogenerated from X11/keysymdef.h
// NOTE: This file will be used on other platforms as well by mapping
//       their keysyms to the X11 keysyms

#ifndef {headerguard}
#define {headerguard}
'''.format(headerguard=args.cxx_header_guard))

    if args.cxx_namespace:
        namespace_stack = list(
            filter(lambda x: bool(x),
                   map(lambda x: x.strip(),
                       args.cxx_namespace.split("::"))))
    else:
        namespace_stack = []

    if namespace_stack:
        fo.write("\n")
        for namespace in namespace_stack:
            fo.write("namespace {} {{\n".format(namespace))

    fo.write("\n")

    if not args.cxx_enum:
        for name, hex in names:
            name = mangle_cxx_name(name)
            fo.write("static const {int_t} {name} = {hex};\n".format(
                int_t=args.cxx_integer_type,
                name=name,
                hex=hex))
    else:
        fo.write("enum {enum_name} : {int_t} {{\n".format(
            enum_name=args.cxx_enum,
            int_t=args.cxx_integer_type))

        for name, hex in names:
            name = mangle_cxx_name(name)
            fo.write("    {name} = {hex},\n".format(
                name=name,
                hex=hex))

        fo.write("};\n")

    if namespace_stack:
        fo.write("\n")
        for namespace in namespace_stack:
            fo.write("}\n")

    fo.write("\n")
    fo.write("#endif\n")

def write_python(fo, args, names):
    # write header
    fo.write('''# Do not edit -- autogenerated from X11/keysymdef.h
# NOTE: This file is used on other platforms as well
# by mapping their keysyms to the X11 keysyms
    """
    Keysymbol names
    """
    ''')

    # write keysymbols
    for name, hex in names:
        if name[0] in '0123456789':
            name = '_' + name
        fo.write('{name} = {hex}\n'.format(name=name, hex=hex))

    if not args.py_reverse_lookup:
        return

    # write reverse lookup
    written = set()
    fo.write('REVERSE = {\n')
    for name, hex in names:
        # filter synonymous mnemonics
        if hex not in written:
            fo.write('{hex}: "{name}",\n'.format(name=name, hex=hex))
            written.add(hex)
    fo.write('}\n')


if __name__ == "__main__":
    import argparse
    import sys

    writers = {
        "python": write_python,
        "c++": write_cxx_header
    }

    parser = argparse.ArgumentParser()
    parser.add_argument(
        "keysymdef",
        metavar="KEYSYMFILE",
        help="Path to X11/keysymdef.h file",
        type=argparse.FileType("r")
    )
    parser.add_argument(
        "outfile",
        metavar="OUTFILE",
        help="Path to write the generated output to",
        type=argparse.FileType("w")
    )
    parser.add_argument(
        "-f", "--format",
        default="python",
        choices=writers.keys(),
        help="Which type of output to generate"
    )
    parser.add_argument(
        "--cxx-namespace",
        default=None,
        help="Namespace to put the constants in (only for c++ output)"
    )
    parser.add_argument(
        "--cxx-header-guard",
        default="_AUTOGEN_KEYSYMS_H",
        help="Header guard (only for c++ output)"
    )
    parser.add_argument(
        "--cxx-enum",
        default=False,
        help="If set, use an enum type for the keysym constants."
    )
    parser.add_argument(
        "--cxx-integer-type",
        default="uint32_t",
        help="Specify which integer type to use for the constants."
    )

    parser.add_argument(
        "--py-no-reverse-lookup",
        dest="py_reverse_lookup",
        default=True,
        action="store_false",
        help="If given, no reverse lookup table will be created"
    )

    args = parser.parse_args()

    with args.keysymdef as f:
        names = parse_keysymdefs(f)

    writer = writers[args.format]

    with args.outfile as f:
        writer(f, args, names)
