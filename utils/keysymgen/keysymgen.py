#!/usr/bin/python2
# encoding=utf8
"""
Parse X11/keysymdef.h (given as first argument), generate
our own keysym list from it as a python source file
"""

import sys
import re

if len(sys.argv) != 3:
    print >>sys.stderr, "Foo: I need two arguments X11/keysymdef.h and the target file"
    exit(1)

fi = open(sys.argv[1], 'r')
fo = open(sys.argv[2], 'w')

# this regex was adapted from keysymdef.h
# all other lines are ignored (perhaps add #ifdef processing
# for language groups)
defre = re.compile(r'^#define XK_(?P<name>[a-zA-Z_0-9]+)\s+(?P<hex>0x[0-9a-f]+)\s*(?P<comment>\/\*\s*(.*)\s*\*\/)?\s*$')

names = []

# read keysym names and numerical values
for line in fi:
    match = defre.match(line)
    if match:
        names.append((match.group('name'), match.group('hex')))

# write header
fo.write('''# Do not edit -- autogenerated from X11/keysymdef.h
# NOTE: This file is used on other platforms as well
# by mapping their keysyms to the X11 keysyms
"""
Keysymbol names
"""
''')

# write keysymbols
for name, hex in names:
    if name[0] in '0123456789':
        name = '_' + name
    fo.write('{name} = {hex}\n'.format(name=name, hex=hex))

# write reverse lookup
written = set()
fo.write('REVERSE = {\n')
for name, hex in names:
    # filter synonymous mnemonics
    if hex not in written:
        fo.write('{hex}: "{name}",\n'.format(name=name, hex=hex))
        written.add(hex)
fo.write('}\n')
